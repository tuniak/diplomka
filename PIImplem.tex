\chapter{Implementation of the Pair-Interaction LGCA in 3D}

"Programmers waste enormous amounts of time thinking about, or worrying about, the speed of noncritical parts of their programs, and these attempts at efficiency actually have a strong negative impact when debugging and maintenance are considered. We should forget about small efficiencies, say about 97\% of the time: premature optimization is the root of all evil. Yet we should not pass up our opportunities in that critical 3\%." 
Donald Knuth in "Structured programming with GoTo statement".

For sure, the implementation of the collision algorithm is in the critical 3\%, as it is repeated more then $10^8$ times per one update of the lattice.

With some knowledge of C compiler, we could do better, but for our own applications, this should be enough.


\section{Implementation of the collision algorithm}
\begin{lstlisting}
// The node consists of 8 cells represented by single bits on the first, second, ... and eighth position.
#define A 1
#define B 2
#define C 4
#define D 8
#define E 16
#define F 32
#define G 64
#define H 128

/* To iterate over the cells, we arrange it in the char */
unsigned char cell[8] = {A, B, C, D, E, F, G, H};

/* The definition of the type Node. It consists of 8 mass bits (char m) and 3x8 momentum bits (char p[3]). It the node is part of the obstacle, node.o == 1. */
typedef struct
{
	unsigned char m;
	unsigned char p[3];
	int o;
} Node;
// Sure. char would be enough for and obstacle, but does not 64 bit processor prefer to manage 64 bit structures (m + p[3] + o = 64 bits)?

// 3 directions (X, Y, Z), 4 pair-interactions in each direction, 2 cells in each pair 
unsigned char Pair[3][4][2] = 
{
	{
		{A,E}, {B,F}, {C,G}, {D,H}
	},
	{
		{A,C}, {B,D}, {E,G}, {F,H}
	},
	{
		{A,B}, {C,D}, {E,F}, {G,H}
	}
};

// Finally we have have everything prepared for the collision algorithm.
Node collision(Node node)
{
	//mass
	unsigned char m = node.m;
	
	//momentum
    unsigned char * p = node.p;

	//d,u ... index for downer and upper momentum
	int d,u;
    
	// l, r ... left/right cell in the pair
	// ml, mr are non-zero, if there is a particle in the left/right cell of the pair (mass-left, mass-right)
	// lu, ld, ru, rd ... momenta of the particles (left-upper, left-downer, right-upper, right-downer)
	unsigned char l, r, ml, mr, lu, ld, ru, rd;

	for (int i = 0; i < 3; ++i)
	{
		d = (i+1) % 3;
		u = (i+2) % 3;
		for (int j = 0; j < 4; ++j)
		{		
			l  = Pair[i][j][0];
			r  = Pair[i][j][1];
			
			ml = m&l;
			mr = m&r;
			ld = p[d]&l;
			lu = p[u]&l;
			rd = p[d]&r;
			ru = p[u]&r;
			
			/* PAIR INTERACTIONS */
			// case 6a
			if (ml && mr)
			{
				if (lu && ru && !ld && !rd)
				{
					p[d] |= l;
					p[d] |= r;
				}	
				//case 6b
				else if (lu && ru && ld && rd)
				{
					p[d] ^= l;
					p[d] ^= r;
				}
				//case 7a 
				else if (ld && !lu && ru && rd)
				{
					p[d] ^= l;
					p[u] |= l;
					p[d] ^= r;
					p[u] ^= r;
				}
				else if (ld && lu && !ru && rd)
				{	
					p[d] ^= l;
					p[d] ^= r;
					p[u] ^= l;
					p[u] |= r;
				}
				//case 7b
				else if (!ld && lu && !ru && !rd)
				{
					p[d] |= l;
					p[d] |= r;
					p[u] ^= l;
					p[u] |= r;
				}
				else if (!ld && !lu && ru && !rd)
				{
					p[d] |= l;
					p[d] |= r;
					p[u] |= l;
					p[u] ^= r;
				}
				//case 8a
				else if (ld && !lu && ru && !rd)
				{
					p[u] |= l;
					p[u] ^= r;
				}
				else if (!ld && lu && !ru && rd)
				{
					p[u] |= r;
					p[u] ^= l;
				}
				//case 8b  
				else if (ld && lu && !ru && !rd)
				{
					p[u] |= l;
					p[u] ^= r;
				}
				else if (!ld && !lu && ru && rd)
				{
					p[u] |= r;
					p[u] ^= l;
				}
				//case 9a
				else if (!ld && !lu && !ru && !rd)
				{
					p[d] |= l;
					p[d] |= r;
				}
				//case 9b
				else if (ld && rd && !lu && !ru)
				{
					p[d] ^= l;
					p[d] ^= r;
				}
			}
			//case 10a
			else if (!ml && mr && ru && !rd)
			{
				m |= l;
				m ^= r;
				p[u] ^= r;
				p[u] |= l;
				if (p[i]&r)
				{
					p[i] ^= r;
					p[i] |= l;
				}
			}
			//case 10b
			else if (ml && !mr && lu && !ld)
			{
				m ^= l;
				m |= r;
				p[u] ^= l;
				p[u] |= r;
				if (p[i]&l)
				{
					p[i] ^= l;
					p[i] |= r;
				}
			}
			//case 11a
			else if (!ml && mr && !ru && !rd)
			{
				m |= l;
				m ^= r;
				if (p[i]&r)
				{
					p[i] ^= r;
					p[i] |= l;
				}
			}
			//case 11b
			else if (ml && !mr && !lu && !ld)
			{
				m |= r;
				m ^= l;
				if (p[i]&l)
				{
					p[i] ^= l;
					p[i] |= r;
				}
			}			
		}
	}	
	node.m = m;
	for(int i = 0; i < 3; ++i)
		node.p[i] = p[i];
	return node;
}

// This function resolves the collisions for all nodes on the lattice. 
// This is the function we call from main().
void Collision(Node***array, int X, int Y, int Z, int start)
{
	int x,y,z;

#pragma omp parallel for private (x,y,z)
	for (x = start; x < X; x+=2)
	{
		for(y = start; y < Y; y+=2)
		{
			for(z = start; z < Z; z+=2)
			{
				if(array[x][y][z].o)
					break;
				array[x][y][z] = collision(array[x][y][z]);
			}
		}
	}
}
\end{lstlisting}


\section{Implementation of the Propagation}
Before we comment on the implementation, we want to emphasize one of the strong sides of PI automaton.

In FCHC, the lattice consisted of all the nodes with the discrete Cartesian coordinates (up to some upper boundary denoted by X, Y, Z).
All of these nodes were interconnected and formed single lattice.

But the same lattice for Pair-Interaction automaton would contain $4$ independent sub-lattices. 

Let us consider node that has all Cartesian indices odd. It is connected to 8 nodes that have even Cartesian indices (because lattice vectors for PI are exclusively $\pm 1$).
These nodes create one of the four sub-lattices.


Another thing is, that we can avoid spurious Zannetti invariants if, for example, nodes with even indices are occupied at even time steps, and odd nodes at odd times.
(for more on Zanneti invariants, see page blabla in \cite{wolf}).

This gives us additional speed-up in computation, as we do not need two distinct lattices for FCHC (or FHP).

\begin{lstlisting}
/* Group of cells that propagates in X-direction, Y-direction and Z-direction respectively. */
#define dirX (B+D+F+H)
#define dirY (E+F+G+H)
#define dirZ (A+B+E+F)
/* For example, because A & dirX == 0, particle in the cell A propagates in -X direction,
    but A & dirZ == 1, so it propagates in (positive) Z direction. */

// Implements periodic boundary condition.
// If index n flows under 0 or over upper boundary N, we assign it value from the other side of boundary.
int PeriodicBC(int n, int N)
{
	if (n<0) return	N-1;
	else if (n<N) return n;
	// else n==N
	else return 0;
}

/* This function propagates particles among the nodes. */
/* If start == 0, we are at the even time step. Then it propagates from nodes with even indices (e.g. at position [0,2,124] on the lattice) to the nodes with odd indices (e.g. to the [1,1,123] etc). */
/* If start == 1, we are at the odd time step. Then it propagates from odd indices to the even indices. */

void Propagation(Node***array, int X, int Y, int Z, int start)
{
	Node node;
	unsigned char m;
	unsigned char*p;
    int x, y, z;
	int xN, yN, zN;
	int c, i;

#pragma omp parallel for private (m, p, x, y, z, xN, yN, zN, c, i)
	// Depending on start, we go through odd or even nodes
    for(x = start; x < X; x+=2)
	{
		for(y = start; y < Y; y+=2)
		{
			for(z = start; z < Z; z+=2)
			{
				// mass of the cells in the node (tells us which cells are occupied)
				m = array[x][y][z].m;
				// momentum of the particles in the node
				p = array[x][y][z].p;
			
				// we look at each cell in node
				for (c = 0; c < 8; ++c)
				{
					//if there is particle in the cell, we want to propagate it to corresponding node
					if(m & cell[c])
					{
						// if particle from cell[c] propagates in positive direction of X
						if (cell[c] & dirX)
							xN = PeriodicBC(x+1,X);
						// else particle propagates in negative direction of x
						else
							xN = PeriodicBC(x-1,X);
						if (cell[c] & dirY)
							yN = PeriodicBC(y+1,Y);
						else
							yN = PeriodicBC(y-1,Y);
						if (cell[c] & dirZ)
							zN = PeriodicBC(z+1,Z);
						else
							zN = PeriodicBC(z-1,Z);

						// if there is obstacle in the new node,
						// it stays in the old node, but we reflect it to diagonal cell
						if( array[xN][yN][zN].o )
						{
							array[xN][yN][zN].m |= cell[7-c];
							for (i = 0; i < 3; ++i)
							{
								if(p[i] & cell[c])
									array[xN][yN][zN].p[i] |= cell[7-c];
							}
							/*particles disappear on 0 and Z-1 */
							// this holds in this particular computation
														
							if(zN == 0 || zN == Z-1)
							{
								array[xN][yN][zN].m = 0;
								for (int i = 0; i < 3; ++i)
								{
									array[xN][yN][zN].p[i] = 0;
								}
							}
						}	
						else //if there is no obstacle in the new node, we propagate particle to the new node
						{
							array[xN][yN][zN].m |= cell[c];
							for(i = 0; i < 3; ++i)
							{
								if(p[i] & cell[c])
									array[xN][yN][zN].p[i] |= cell[c];
							}
							/*particles disappear on the 0 and X-1 */
														
							if (zN == 0 || zN == Z-1)
							{
								array[xN][yN][zN].m = 0;
								for (i = 0; i < 3; ++i)
									array[xN][yN][zN].p[i] = 0;
							}
						}
					}
				}
				//in the old array, we set the node to 0
				array[x][y][z].m = 0;
				for(i = 0; i < 3; ++i)
				{
					array[x][y][z].p[i] = 0;
				}
			}
		}
	}
}
\end{lstlisting}h